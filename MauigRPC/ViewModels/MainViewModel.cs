using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using MauigRPC.Services;
using System.Diagnostics;

namespace MauigRPC.ViewModels;

/// <summary>
/// ViewModel for the MainPage demonstrating gRPC integration with MVVM pattern.
/// Uses CommunityToolkit.Mvvm source generators for automatic INotifyPropertyChanged implementation.
/// </summary>
/// <remarks>
/// This ViewModel demonstrates best practices for integrating gRPC proto models with MVVM:
/// 
/// <strong>MVVM Toolkit Features Used:</strong>
/// - [ObservableProperty] - Generates property changed notifications automatically
/// - [RelayCommand] - Generates ICommand implementations with CanExecute support
/// - ObservableObject - Base class providing INotifyPropertyChanged implementation
/// 
/// <strong>gRPC Integration Pattern:</strong>
/// Proto models (HelloRequest, HelloReply) are used as DTOs (Data Transfer Objects) for gRPC communication only.
/// The ViewModel exposes observable properties that are independent of proto models, following separation of concerns.
/// This approach:
/// - Keeps proto models as pure data contracts
/// - Allows UI-specific properties (loading states, validation)
/// - Enables testing without proto dependencies
/// - Provides clean abstraction layer
/// 
/// <strong>Key Responsibilities:</strong>
/// - Managing user input (Name property)
/// - Handling gRPC service calls asynchronously
/// - Managing UI state (loading indicators, responses)
/// - Error handling and user feedback
/// - Command execution logic
/// </remarks>
public partial class MainViewModel : ObservableObject
{
    /// <summary>
    /// The gRPC service injected via constructor for making remote procedure calls.
    /// </summary>
    private readonly GrpcGreeterService _grpcService;

    /// <summary>
    /// Backing field for the user's name input.
    /// The [ObservableProperty] attribute automatically generates:
    /// - Public Name property
    /// - OnPropertyChanged notification
    /// - SetProperty implementation
    /// </summary>
    /// <remarks>
    /// Generated property signature:
    /// <code>
    /// public string Name
    /// {
    ///     get => name;
    ///     set => SetProperty(ref name, value);
    /// }
    /// </code>
    /// This keeps the proto model (HelloRequest) separate from the ViewModel.
    /// When calling gRPC, we map: HelloRequest { Name = this.Name }
    /// </remarks>
    [ObservableProperty]
    private string name = "MAUI Client";

    /// <summary>
    /// Backing field for the gRPC response message.
    /// Generated property updates the UI automatically when the response arrives from the server.
    /// </summary>
    [ObservableProperty]
    private string responseMessage = "Response will appear here";

    /// <summary>
    /// Backing field for loading state indicator.
    /// Controls visibility and animation of the ActivityIndicator in the UI.
    /// Demonstrates UI state management independent of proto models.
    /// </summary>
    [ObservableProperty]
    private bool isLoading;

    /// <summary>
    /// Backing field for button enabled state.
    /// Prevents multiple concurrent gRPC calls while one is in progress.
    /// </summary>
    [ObservableProperty]
    private bool isButtonEnabled = true;

    /// <summary>
    /// Initializes a new instance of the MainViewModel.
    /// </summary>
    /// <param name="grpcService">The gRPC greeter service injected by the DI container.</param>
    /// <remarks>
    /// The service is registered as a Singleton in MauiProgram.cs, ensuring
    /// the gRPC channel is reused efficiently across all calls.
    /// </remarks>
    public MainViewModel(GrpcGreeterService grpcService)
    {
        _grpcService = grpcService;
    }

    /// <summary>
    /// Command to call the gRPC service. Generated by [RelayCommand] attribute.
    /// </summary>
    /// <remarks>
    /// The [RelayCommand] attribute automatically generates:
    /// - Public IAsyncRelayCommand CallGrpcCommand property
    /// - Command implementation with CanExecute logic
    /// - Automatic exception handling integration
    /// - Support for async/await operations
    /// 
    /// Generated command signature:
    /// <code>
    /// public IAsyncRelayCommand CallGrpcCommand { get; }
    /// </code>
    /// 
    /// <strong>MVVM Pattern Benefits:</strong>
    /// - Testable: Can test command logic without UI
    /// - Reusable: Command can be bound to multiple controls
    /// - Maintainable: Business logic separated from UI code
    /// - Type-safe: Compile-time binding validation
    /// 
    /// <strong>gRPC Proto Model Integration:</strong>
    /// This method demonstrates the recommended pattern for using proto models:
    /// 1. Create proto request from ViewModel properties (HelloRequest { Name = Name })
    /// 2. Call gRPC service with proto model
    /// 3. Extract data from proto response (reply.Message)
    /// 4. Update ViewModel properties (not proto objects)
    /// 
    /// This keeps proto models as DTOs and maintains clean separation between:
    /// - Communication layer (proto models)
    /// - Presentation layer (ViewModel properties)
    /// - UI layer (View bindings)
    /// 
    /// <strong>Flow Diagram:</strong>
    /// <code>
    /// User Input → ViewModel.Name (Observable)
    ///                     ↓
    ///              CallGrpcAsync()
    ///                     ↓
    ///         Create HelloRequest { Name }  ← Proto Model (DTO)
    ///                     ↓
    ///         gRPC Service Call (HTTP/2 + Protobuf)
    ///                     ↓
    ///         Receive HelloReply { Message } ← Proto Model (DTO)
    ///                     ↓
    ///         Extract: reply.Message
    ///                     ↓
    ///         ViewModel.ResponseMessage ← Observable Property
    ///                     ↓
    ///         UI Updates (Data Binding)
    /// </code>
    /// 
    /// <strong>Error Handling:</strong>
    /// Catches all exceptions and displays user-friendly messages.
    /// In production, consider:
    /// - Retry logic with exponential backoff
    /// - Specific exception handling (RpcException)
    /// - Logging for monitoring and debugging
    /// - Circuit breaker pattern for resilience
    /// 
    /// <strong>Performance Considerations:</strong>
    /// - gRPC binary protobuf is ~60% smaller than JSON
    /// - HTTP/2 multiplexing allows concurrent calls
    /// - Singleton service reuses connections (~40% faster)
    /// </remarks>
    [RelayCommand]
    private async Task CallGrpcAsync()
    {
        try
        {
            // Update UI state - show loading
            IsLoading = true;
            IsButtonEnabled = false;
            ResponseMessage = "Calling gRPC service...";

            // Validate input
            var nameToSend = string.IsNullOrWhiteSpace(Name) ? "MAUI Client" : Name;

            // Call gRPC service
            // Note: The service internally creates HelloRequest proto model from the string
            // This is where the proto model is used as a DTO for gRPC communication
            string response = await _grpcService.SayHelloAsync(nameToSend);

            // Update UI with response
            // We extract the message from the proto response and store it as a simple string
            ResponseMessage = response;
            Debug.WriteLine($"gRPC Response: {response}");

#if ANDROID || IOS
            // Announce to screen reader for accessibility
            SemanticScreenReader.Announce(response);
#endif
        }
        catch (Exception ex)
        {
            // Handle errors gracefully
            ResponseMessage = $"Error: {ex.Message}";
            Debug.WriteLine($"gRPC Error: {ex.Message}");
            
            // In a real app, you might want to show a dialog or toast
            // await Application.Current?.MainPage?.DisplayAlert("Error", ex.Message, "OK")!;
        }
        finally
        {
            // Always reset UI state
            IsLoading = false;
            IsButtonEnabled = true;
        }
    }
}
