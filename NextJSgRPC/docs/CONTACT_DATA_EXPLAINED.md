# Contact Data Structure Explained (for .NET Developers)

A detailed guide explaining how contact data flows through the Next.js app, with comparisons to your .NET MAUI app.

---

## üéØ Overview

In your **MAUI app**, contact data flows like this:
```
C# Code ‚Üí gRPC Client ‚Üí gRPC Server ‚Üí C# Objects
```

In **Next.js**, there's an extra step:
```
React UI (Browser) ‚Üí API Route (Node.js) ‚Üí gRPC Client ‚Üí gRPC Server
```

**Key Challenge:** Different naming conventions!
- **gRPC (Proto files):** Uses `snake_case` (e.g., `phone_numbers`, `zip_code`)
- **JavaScript/TypeScript:** Uses `camelCase` (e.g., `phoneNumbers`, `zipCode`)
- **C#:** Uses `PascalCase` (e.g., `PhoneNumbers`, `ZipCode`) - automatically converted by gRPC tools

---

## üìä The Contact Model

### Proto Definition (contact.proto)
```protobuf
message Contact {
  int32 id = 1;
  string name = 2;
  Address address = 3;
  repeated PhoneNumber phone_numbers = 4;  // Note: snake_case
}

message Address {
  string street = 1;
  string city = 2;
  string state = 3;
  string zip_code = 4;  // Note: snake_case
  string country = 5;
}

message PhoneNumber {
  string number = 1;
  PhoneType type = 2;
}

enum PhoneType {
  MOBILE = 0;
  HOME = 1;
  WORK = 2;
}
```

### How It Looks in C# (Your MAUI App)
```csharp
// Auto-generated by gRPC tools - PascalCase!
public class Contact
{
    public int Id { get; set; }
    public string Name { get; set; }
    public Address Address { get; set; }
    public List<PhoneNumber> PhoneNumbers { get; set; }  // ‚Üê PascalCase!
}

public class Address
{
    public string Street { get; set; }
    public string City { get; set; }
    public string State { get; set; }
    public string ZipCode { get; set; }  // ‚Üê PascalCase!
    public string Country { get; set; }
}
```

### How It Looks in TypeScript (Next.js gRPC Client)
```typescript
// src/lib/grpc-clients.ts
// When we receive data from gRPC, it's snake_case
export interface Contact {
  id: number;
  name: string;
  address?: Address;
  phone_numbers: PhoneNumber[];  // ‚Üê snake_case from gRPC!
}

export interface Address {
  street: string;
  city: string;
  state: string;
  zip_code: string;  // ‚Üê snake_case from gRPC!
  country: string;
}
```

### How It Looks in React UI (Frontend)
```typescript
// src/app/contacts/page.tsx
// We convert to camelCase for JavaScript convention
interface Contact {
  id: number;
  name: string;
  address?: Address;
  phoneNumbers?: PhoneNumber[];  // ‚Üê camelCase for UI!
}

interface Address {
  street: string;
  city: string;
  state: string;
  zipCode: string;  // ‚Üê camelCase for UI!
  country: string;
}
```

---

## üîÑ Data Transformation Flow

### 1. Getting Contacts (GET Request)

#### Step 1: React Component Requests Data
```typescript
// src/app/contacts/page.tsx
const response = await fetch('/api/contacts');
const data = await response.json();
setContacts(data.contacts);  // Expects camelCase
```

#### Step 2: API Route Receives Request
```typescript
// src/app/api/contacts/route.ts
export async function GET(request: NextRequest) {
  const client = new ContactClient(serverAddress);
  const response = await client.getAllContacts();
  
  // Response from gRPC has snake_case!
  // response.contacts[0].phone_numbers
  // response.contacts[0].address.zip_code
```

#### Step 3: Convert snake_case to camelCase
```typescript
// Helper function in route.ts
function convertContactToCamelCase(contact: any) {
  return {
    id: contact.id,
    name: contact.name,
    address: contact.address ? {
      street: contact.address.street,
      city: contact.address.city,
      state: contact.address.state,
      zipCode: contact.address.zip_code,  // ‚Üê Convert!
      country: contact.address.country,
    } : undefined,
    phoneNumbers: contact.phone_numbers || [],  // ‚Üê Convert!
  };
}
```

#### Step 4: Return camelCase Data
```typescript
const contacts = response.contacts.map(convertContactToCamelCase);

return NextResponse.json({
  success: true,
  contacts,  // Now in camelCase!
});
```

#### Step 5: React Component Displays Data
```typescript
// Now the UI can use camelCase naturally:
{contact.phoneNumbers?.map((phone) => (
  <div>{phone.number} - {phone.type}</div>
))}
```

### 2. Creating a Contact (POST Request)

The flow is **reversed** - we convert FROM camelCase TO snake_case:

#### Step 1: React Form Submits camelCase Data
```typescript
// src/app/contacts/add/page.tsx
const formData = {
  name: 'John Doe',
  address: {
    street: '123 Main St',
    zipCode: '12345',  // camelCase
  },
  phoneNumbers: [
    { number: '555-1234', type: 'MOBILE' }
  ]
};

const response = await fetch('/api/contacts', {
  method: 'POST',
  body: JSON.stringify(formData),
});
```

#### Step 2: API Route Converts to snake_case
```typescript
// src/app/api/contacts/route.ts
export async function POST(request: NextRequest) {
  const { name, address, phoneNumbers } = await request.json();
  
  // Convert camelCase TO snake_case for gRPC
  const contactRequest = {
    name,
    address: address ? {
      street: address.street,
      city: address.city,
      state: address.state,
      zip_code: address.zipCode,  // ‚Üê Convert!
      country: address.country,
    } : undefined,
    phone_numbers: phoneNumbers || [],  // ‚Üê Convert!
  };
  
  const client = new ContactClient(serverAddress);
  const response = await client.createContact(contactRequest);
  
  // Convert response back to camelCase before returning
  return NextResponse.json({
    contact: convertContactToCamelCase(response.contact),
  });
}
```

---

## üÜö Comparison with C# MAUI

### In Your C# MAUI App

#### Getting Contacts
```csharp
// MAUI/MainPage.xaml.cs
var channel = GrpcChannel.ForAddress("http://localhost:5195");
var client = new ContactService.ContactServiceClient(channel);

var response = await client.GetAllContactsAsync(new GetAllContactsRequest());

// Already in PascalCase! No conversion needed.
foreach (var contact in response.Contacts)
{
    Console.WriteLine(contact.Name);
    Console.WriteLine(contact.Address.ZipCode);  // PascalCase
    foreach (var phone in contact.PhoneNumbers)  // PascalCase
    {
        Console.WriteLine($"{phone.Number} - {phone.Type}");
    }
}
```

**Why no conversion?** The C# gRPC tools automatically convert from proto's snake_case to C#'s PascalCase at compile time!

### In Next.js

#### Getting Contacts
```typescript
// Browser: src/app/contacts/page.tsx
const response = await fetch('/api/contacts');  // HTTP to API route
const data = await response.json();

// camelCase after conversion
data.contacts.forEach(contact => {
  console.log(contact.name);
  console.log(contact.address.zipCode);  // camelCase
  contact.phoneNumbers.forEach(phone => {
    console.log(`${phone.number} - ${phone.type}`);
  });
});
```

**Why conversion?** We manually convert in the API route to follow JavaScript naming conventions.

---

## üí° Why This Matters

### Problem Without Conversion
If we didn't convert, your React code would look like this:

```typescript
// ‚ùå Mixing conventions - confusing!
<div>
  <h2>{contact.name}</h2>  {/* camelCase */}
  <p>{contact.address.zip_code}</p>  {/* snake_case - inconsistent! */}
  {contact.phone_numbers.map(...)}  {/* snake_case - inconsistent! */}
</div>
```

### Solution With Conversion
```typescript
// ‚úÖ Consistent camelCase - clean!
<div>
  <h2>{contact.name}</h2>  {/* camelCase */}
  <p>{contact.address.zipCode}</p>  {/* camelCase - consistent! */}
  {contact.phoneNumbers.map(...)}  {/* camelCase - consistent! */}
</div>
```

---

## üîç Where to Find the Code

### 1. Proto Definitions
**File:** `NextJSgRPC/proto/contact.proto`
- Defines the contract (snake_case)

### 2. gRPC Client (Uses snake_case)
**File:** `NextJSgRPC/src/lib/grpc-clients.ts`
- TypeScript interfaces matching proto structure
- Snake_case because it matches gRPC wire format

### 3. API Route (Conversion Layer)
**File:** `NextJSgRPC/src/app/api/contacts/route.ts`
- **GET:** Converts snake_case ‚Üí camelCase
- **POST/PUT:** Converts camelCase ‚Üí snake_case
- Helper function: `convertContactToCamelCase()`

### 4. React Components (Uses camelCase)
**Files:**
- `NextJSgRPC/src/app/contacts/page.tsx` - List view
- `NextJSgRPC/src/app/contacts/add/page.tsx` - Add form
- `NextJSgRPC/src/app/contacts/edit/[id]/page.tsx` - Edit form

---

## üìã Complete Data Flow Example

### Creating a Contact with Address and Phone

```typescript
// 1. USER FILLS FORM (React UI - camelCase)
const formData = {
  name: 'Jane Smith',
  address: {
    street: '456 Oak Avenue',
    city: 'Portland',
    state: 'OR',
    zipCode: '97201',      // camelCase
    country: 'USA',
  },
  phoneNumbers: [          // camelCase
    { number: '503-555-1234', type: 'MOBILE' },
    { number: '503-555-5678', type: 'WORK' },
  ],
};

// 2. SUBMIT TO API ROUTE
const response = await fetch('/api/contacts', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(formData),
});

// 3. API ROUTE CONVERTS (route.ts - snake_case)
const contactRequest = {
  name: 'Jane Smith',
  address: {
    street: '456 Oak Avenue',
    city: 'Portland',
    state: 'OR',
    zip_code: '97201',     // ‚Üí snake_case for gRPC
    country: 'USA',
  },
  phone_numbers: [         // ‚Üí snake_case for gRPC
    { number: '503-555-1234', type: 'MOBILE' },
    { number: '503-555-5678', type: 'WORK' },
  ],
};

// 4. GRPC CLIENT SENDS TO SERVER (grpc-clients.ts)
const client = new ContactClient('localhost:5195');
const grpcResponse = await client.createContact(contactRequest);

// 5. GRPC SERVER RETURNS (snake_case)
grpcResponse.contact = {
  id: 42,
  name: 'Jane Smith',
  address: { zip_code: '97201', ... },
  phone_numbers: [ ... ],
};

// 6. API ROUTE CONVERTS BACK (route.ts - camelCase)
const convertedContact = convertContactToCamelCase(grpcResponse.contact);
// Result: { id: 42, name: '...', address: { zipCode: '97201' }, phoneNumbers: [...] }

// 7. REACT COMPONENT RECEIVES (camelCase)
const data = await response.json();
console.log(data.contact.address.zipCode);  // '97201'
console.log(data.contact.phoneNumbers[0].number);  // '503-555-1234'
```

---

## üé® UI Components Explained

### Contact Card Component

The contact list displays each contact as a card with ALL information:

```typescript
// src/app/contacts/page.tsx
<div className="bg-white shadow rounded-lg p-6">
  {/* Name and ID */}
  <h2>{contact.name}</h2>
  <p>ID: {contact.id}</p>

  {/* Address Section */}
  {contact.address && (
    <div>
      <h3>üìç Address</h3>
      <p>{contact.address.street}</p>
      <p>{contact.address.city}, {contact.address.state} {contact.address.zipCode}</p>
      <p>{contact.address.country}</p>
    </div>
  )}

  {/* Phone Numbers Section */}
  {contact.phoneNumbers && contact.phoneNumbers.length > 0 && (
    <div>
      <h3>üìû Phone Numbers</h3>
      {contact.phoneNumbers.map((phone, idx) => (
        <div key={idx}>
          <span>{phone.number}</span>
          <span className="badge">{phone.type}</span>
        </div>
      ))}
    </div>
  )}
</div>
```

**Comparison to XAML:**
```xml
<!-- Your MAUI equivalent might look like: -->
<Frame>
  <StackLayout>
    <Label Text="{Binding Name}" FontSize="Large" />
    <Label Text="{Binding Id, StringFormat='ID: {0}'}" />
    
    <!-- Address -->
    <StackLayout IsVisible="{Binding Address, Converter={StaticResource NotNullConverter}}">
      <Label Text="üìç Address" FontAttributes="Bold" />
      <Label Text="{Binding Address.Street}" />
      <Label Text="{Binding Address.City}" />
    </StackLayout>
    
    <!-- Phone Numbers -->
    <CollectionView ItemsSource="{Binding PhoneNumbers}">
      <CollectionView.ItemTemplate>
        <DataTemplate>
          <Label Text="{Binding Number}" />
        </DataTemplate>
      </CollectionView.ItemTemplate>
    </CollectionView>
  </StackLayout>
</Frame>
```

---

## üéì Key Takeaways for .NET Developers

### 1. Naming Conventions
| Layer | Convention | Example |
|-------|-----------|---------|
| **Proto** | snake_case | `phone_numbers`, `zip_code` |
| **C# (MAUI)** | PascalCase | `PhoneNumbers`, `ZipCode` |
| **JavaScript/TypeScript** | camelCase | `phoneNumbers`, `zipCode` |

### 2. Conversion Happens in API Route
- **C# MAUI:** Automatic at compile time (by gRPC tools)
- **Next.js:** Manual in API route (at runtime)

### 3. Benefits of This Approach
‚úÖ **Consistent:** Each layer uses its native convention  
‚úÖ **Clean:** React code looks like normal JavaScript  
‚úÖ **Maintainable:** Clear separation of concerns  
‚úÖ **Type-safe:** TypeScript catches errors  

### 4. Similar to Your C# Experience
```csharp
// You're used to this "just working" in C#:
var contact = await client.GetContactAsync(request);
Console.WriteLine(contact.PhoneNumbers[0].Number);  // PascalCase

// In Next.js, we do the same - just with camelCase:
const contact = await getContact(id);
console.log(contact.phoneNumbers[0].number);  // camelCase
```

---

## üêõ Common Issues

### Issue: Phone numbers not showing
**Cause:** Accessing `contact.phone_numbers` instead of `contact.phoneNumbers`  
**Solution:** Use camelCase in React components

### Issue: Error creating contact
**Cause:** Sending camelCase directly to gRPC  
**Solution:** Conversion happens automatically in API route - just send camelCase from React

### Issue: TypeScript errors
**Cause:** Interface mismatch  
**Solution:** Check you're using the right interface in each layer

---

## üìö Related Documentation

- `NEXTJS_VS_DOTNET.md` - Overall framework comparison
- `README.md` - Quick start guide
- `src/app/api/contacts/route.ts` - See conversion code
- `src/lib/grpc-clients.ts` - See gRPC client implementation

---

## üéâ Summary

**What You Need to Know:**

1. **Proto uses snake_case** ‚Üí Your contract with the server
2. **C# auto-converts to PascalCase** ‚Üí You're used to this
3. **JavaScript uses camelCase** ‚Üí Industry standard
4. **API Route handles conversion** ‚Üí You don't have to worry about it in React
5. **React components use camelCase** ‚Üí Clean, consistent code

The conversion layer in the API route acts like the C# gRPC tools - it makes everything "just work" with the right naming convention for the platform! üöÄ
